

## Not relevant to you -- Added "-x" option to the http command

diff --git a/src/http/http.c b/src/http/http.c
index f32edcaa6..92cd7485d 100644
--- a/src/http/http.c
+++ b/src/http/http.c
@@ -657,6 +657,14 @@ static int parseArgs(int argc, char **argv)
             }
             setWorkers++;
 
+        } else if (smatch(argp, "-x")) {
+            //  Undocumented and unsupported (-D --nofollow -s)
+            mprSetDebugMode(1);
+            app->maxRetries = 0;
+            app->timeout = HTTP_UNLIMITED;
+            app->nofollow++;
+            app->showHeaders++;
+
         } else if (smatch(argp, "--zero")) {
             app->zeroOnErrors++;
 


## Increased the monitor prune period from 15 secs to 1 minutes and improved comments
## Added connectionsPerClientMax to HttpLimits

diff --git a/src/http/http.h b/src/http/http.h
index fa08f877e..ac78b50b5 100644
--- a/src/http/http.h
+++ b/src/http/http.h
@@ -123,7 +123,7 @@ struct HttpWebSocket;
     #define ME_HTTP_DELAY_PERIOD    (5 * 60 * 1000)      /**< Default delay IP period */
 #endif
 #ifndef ME_HTTP_MONITOR_PERIOD
-    #define ME_HTTP_MONITOR_PERIOD  (15 * 1000)          /**< Monitor prune period */
+    #define ME_HTTP_MONITOR_PERIOD  (60 * 1000)          /**< Monitor prune period */
 #endif
 #ifndef ME_HTTP_REMEDY_TIMEOUT
     #define ME_HTTP_REMEDY_TIMEOUT  (60 * 1000)          /**< Default remedy command timeout */
@@ -153,7 +153,10 @@ struct HttpWebSocket;
     #define ME_MAX_CLIENTS          32                   /**< Maximum unique client IP addresses */
 #endif
 #ifndef ME_MAX_CONNECTIONS
-    #define ME_MAX_CONNECTIONS      50                   /**< Maximum concurrent client endpoints */
+    #define ME_MAX_CONNECTIONS      50                   /**< Maximum concurrent connections (sockets) for whole server */
+#endif
+#ifndef ME_MAX_CONNECTIONS_PER_CLIENT
+    #define ME_MAX_CONNECTIONS_PER_CLIENT 20             /**< Maximum concurrent connections per client (ip address) */
 #endif
 #ifndef ME_MAX_HPACK_SIZE
     #define ME_MAX_HPACK_SIZE       65536                /**< Maximum size of the hpack table */
@@ -183,7 +186,7 @@ struct HttpWebSocket;
     #define ME_MAX_RX_FORM          (512 * 1024)         /**< Maximum incoming form size (512K) */
 #endif
 #ifndef ME_MAX_REQUESTS_PER_CLIENT
-    #define ME_MAX_REQUESTS_PER_CLIENT 20               /**< Maximum concurrent requests per client */
+    #define ME_MAX_REQUESTS_PER_CLIENT 20               /**< Maximum concurrent requests per client (ip address) */
 #endif
 #ifndef ME_MAX_REWRITE
     #define ME_MAX_REWRITE          20                   /**< Maximum URI rewrites */
@@ -400,14 +403,14 @@ PUBLIC void httpSetForkCallback(MprForkCallback proc, void *arg);
 /*
     Monitored counters. These are per-client IP unless specified.
  */
-#define HTTP_COUNTER_ACTIVE_CLIENTS     0       /**< Active unique client IP addresses */
+#define HTTP_COUNTER_ACTIVE_CLIENTS     0       /**< Active unique client IP addresses (global) */
 #define HTTP_COUNTER_ACTIVE_CONNECTIONS 1       /**< Active connections per client */
 #define HTTP_COUNTER_ACTIVE_REQUESTS    2       /**< Active requests per client */
-#define HTTP_COUNTER_ACTIVE_PROCESSES   3       /**< Total processes for server */
+#define HTTP_COUNTER_ACTIVE_PROCESSES   3       /**< Total processes for server (global) */
 #define HTTP_COUNTER_BAD_REQUEST_ERRORS 4       /**< Bad request format errors */
 #define HTTP_COUNTER_ERRORS             5       /**< All errors */
 #define HTTP_COUNTER_LIMIT_ERRORS       6       /**< Limit violation errors */
-#define HTTP_COUNTER_MEMORY             7       /**< Total application memory for server */
+#define HTTP_COUNTER_MEMORY             7       /**< Total application memory for server (global) */
 #define HTTP_COUNTER_NETWORK_IO         8       /**< Network I/O */
 #define HTTP_COUNTER_NOT_FOUND_ERRORS   9       /**< URI not found errors */
 #define HTTP_COUNTER_REQUESTS           10      /**< Request count */
@@ -442,7 +445,7 @@ typedef struct HttpMonitor {
 } HttpMonitor;
 
 /**
-    Per-IP address structure
+    Per-IP address structure that holds the monitor counters
     @ingroup HttpMonitor HttpMonitor
     @stability Internal
  */
@@ -1465,8 +1468,9 @@ PUBLIC void httpGetStats(HttpStats *sp);
 typedef struct HttpLimits {
     int      cacheItemSize;             /**< Maximum size of a cachable item */
     ssize    chunkSize;                 /**< Maximum chunk size for transfer encoding */
-    int      clientMax;                 /**< Maximum number of unique clients IP addresses */
-    int      connectionsMax;            /**< Maximum number of simultaneous client connections */
+    int      clientMax;                 /**< Maximum number of unique clients (ip addresses) */
+    int      connectionsMax;            /**< Maximum number of simultaneous connections (sockets) for whole server */
+    int      connectionsPerClientMax;   /**< Maximum number of simultaneous connections (sockets) per client (ip address) */
     int      headerMax;                 /**< Maximum number of header lines */
     int      headerSize;                /**< Maximum size of the total header */
     MprTicks inactivityTimeout;         /**< Timeout for keep-alive and idle requests (msec) */
@@ -1476,7 +1480,7 @@ typedef struct HttpLimits {
     int      requestMax;                /**< Maximum number of simultaneous concurrent requests */
     MprTicks requestTimeout;            /**< Time a request can take (msec) */
     MprTicks requestParseTimeout;       /**< Time a request can take to parse the request headers (msec) */
-    int      requestsPerClientMax;      /**< Maximum number of requests per client IP */
+    int      requestsPerClientMax;      /**< Maximum number of requests per client (ip address) */
     MprOff   rxBodySize;                /**< Maximum size of receive body data */
     MprOff   rxFormSize;                /**< Maximum size of form data */
     int      sessionMax;                /**< Maximum number of sessions */




## Add Limits.connectionsPerClientMax initialization
## Add LimitConnectionsPerClient
## Move monitorActiveRequests from http1 to centralize in process.c so that HTTP/2 can use same code
## Fix checkCounter. Was typo for less than monitor comparisons (rarely used)
## Fix httpPruneMonitors to only remove IP address counters when zero active connections
## Fix httpAccept limiting global connections
## Added dates to trace log entries

diff --git a/src/http/httpLib.c b/src/http/httpLib.c
index f1f7087ea..d3530d6c7 100644
--- a/src/http/httpLib.c
+++ b/src/http/httpLib.c
@@ -473,6 +473,7 @@ PUBLIC void httpInitLimits(HttpLimits *limits, bool serverSide)
     limits->chunkSize = ME_MAX_CHUNK;
     limits->clientMax = ME_MAX_CLIENTS;
     limits->connectionsMax = ME_MAX_CONNECTIONS;
+    limits->connectionsPerClientMax = ME_MAX_CONNECTIONS;
     limits->headerMax = ME_MAX_NUM_HEADERS;
     limits->headerSize = ME_MAX_HEADERS;
     limits->keepAliveMax = ME_MAX_KEEP_ALIVE;
@@ -4538,6 +4539,11 @@ static void parseLimitsConnections(HttpRoute *route, cchar *key, MprJson *prop)
 }
 
 
+static void parseLimitsConnectionsPerClient(HttpRoute *route, cchar *key, MprJson *prop)
+{
+    route->limits->connectionsPerClientMax = httpGetInt(prop->value);
+}
+
 static void parseLimitsDepletion(HttpRoute *route, cchar *key, MprJson *prop)
 {
     cchar   *policy;
@@ -4606,7 +4612,7 @@ static void parseLimitsProcesses(HttpRoute *route, cchar *key, MprJson *prop)
 }
 
 
-static void parseLimitsRequests(HttpRoute *route, cchar *key, MprJson *prop)
+static void parseLimitsRequestsPerClient(HttpRoute *route, cchar *key, MprJson *prop)
 {
     route->limits->requestsPerClientMax = httpGetInt(prop->value);
 }
@@ -5705,6 +5711,7 @@ PUBLIC int httpInitParser()
     httpAddConfig("http.limits.chunk", parseLimitsChunk);
     httpAddConfig("http.limits.clients", parseLimitsClients);
     httpAddConfig("http.limits.connections", parseLimitsConnections);
+    httpAddConfig("http.limits.connectionsPerClient", parseLimitsConnectionsPerClient);
     httpAddConfig("http.limits.depletion", parseLimitsDepletion);
     httpAddConfig("http.limits.keepAlive", parseLimitsKeepAlive);
     httpAddConfig("http.limits.files", parseLimitsFiles);
@@ -5714,7 +5721,7 @@ PUBLIC int httpInitParser()
     httpAddConfig("http.limits.rxHeader", parseLimitsRxHeader);
     httpAddConfig("http.limits.packet", parseLimitsPacket);
     httpAddConfig("http.limits.processes", parseLimitsProcesses);
-    httpAddConfig("http.limits.requests", parseLimitsRequests);
+    httpAddConfig("http.limits.requests", parseLimitsRequestsPerClient);
     httpAddConfig("http.limits.sessions", parseLimitsSessions);
     httpAddConfig("http.limits.txBody", parseLimitsTxBody);
     httpAddConfig("http.limits.upload", parseLimitsUpload);
@@ -8859,7 +8866,6 @@ static char *getToken(HttpPacket *packet, cchar *delim, int validation);
 static bool gotHeaders(HttpQueue *q, HttpPacket *packet);
 static void logPacket(HttpQueue *q, HttpPacket *packet);
 static void incomingHttp1(HttpQueue *q, HttpPacket *packet);
-static bool monitorActiveRequests(HttpStream *stream);
 static void outgoingHttp1(HttpQueue *q, HttpPacket *packet);
 static void outgoingHttp1Service(HttpQueue *q);
 static HttpPacket *parseFields(HttpQueue *q, HttpPacket *packet);
@@ -8983,9 +8989,6 @@ static HttpPacket *parseHeaders1(HttpQueue *q, HttpPacket *packet)
     assert(stream->tx);
     rx = stream->rx;
 
-    if (!monitorActiveRequests(stream)) {
-        return 0;
-    }
     if (!gotHeaders(q, packet)) {
         /* Don't yet have a complete header, or error */
         return (q->stream->error) ? NULL : packet;
@@ -9001,29 +9004,6 @@ static HttpPacket *parseHeaders1(HttpQueue *q, HttpPacket *packet)
 }
 
 
-static bool monitorActiveRequests(HttpStream *stream)
-{
-    HttpLimits  *limits;
-    int64       value;
-
-    limits = stream->limits;
-
-    if (httpServerStream(stream) && !stream->activeRequest) {
-        /*
-            ErrorDocuments may come through here twice so test activeRequest to keep counters valid.
-         */
-        stream->activeRequest = 1;
-        if ((value = httpMonitorEvent(stream, HTTP_COUNTER_ACTIVE_REQUESTS, 1)) >= limits->requestsPerClientMax) {
-            httpError(stream, HTTP_ABORT | HTTP_CODE_SERVICE_UNAVAILABLE,
-                "Too many concurrent requests for client: %s %d/%d", stream->ip, (int) value, limits->requestsPerClientMax);
-            return 0;
-        }
-        httpMonitorEvent(stream, HTTP_COUNTER_REQUESTS, 1);
-    }
-    return 1;
-}
-
-
 static cchar *eatBlankLines(HttpPacket *packet)
 {
     MprBuf  *content;
@@ -11356,14 +11336,8 @@ static HttpStream *createStream(HttpQueue *q, HttpPacket *packet)
         frame->stream = stream;
 
         /*
-            Servers create a new connection stream. Note: HttpStream is used for HTTP/2 streams (legacy).
+            Servers create a new connection stream
          */
-        if (mprGetListLength(net->streams) >= net->limits->requestsPerClientMax) {
-            sendReset(q, stream, HTTP2_REFUSED_STREAM, "Too many streams for IP: %s %d/%d", net->ip,
-                (int) mprGetListLength(net->streams), net->limits->requestsPerClientMax);
-            return 0;
-        }
-        httpMonitorEvent(stream, HTTP_COUNTER_REQUESTS, 1);
         if (mprGetListLength(net->streams) >= net->limits->streamsMax) {
             sendReset(q, stream, HTTP2_REFUSED_STREAM, "Too many streams for connection: %s %d/%d", net->ip,
                 (int) mprGetListLength(net->streams), net->limits->streamsMax);
@@ -13162,7 +13136,7 @@ PUBLIC ssize httpHuffEncode(cchar *src, ssize size, char *dst, uint lower)
 
 /********************************** Forwards **********************************/
 
-static HttpAddress *growAddresses(HttpNet *net, HttpAddress *address, int counterIndex);
+static HttpAddress *growCounters(HttpNet *net, HttpAddress *address, int counterIndex);
 static MprTicks lookupTicks(MprHash *args, cchar *key, MprTicks defaultValue);
 static void stopMonitors(void);
 
@@ -13264,7 +13238,7 @@ static void checkCounter(HttpMonitor *monitor, HttpCounter *counter, cchar *ip)
             fmt = "Monitor%s for \"%s\". Value %lld per %lld secs exceeds limit of %lld.";
         }
 
-    } else if (monitor->expr == '>') {
+    } else if (monitor->expr == '<') {
         if (counter->value < monitor->limit) {
             fmt = "Monitor%s for \"%s\". Value %lld per %lld secs outside limit of %lld.";
         }
@@ -13305,9 +13279,15 @@ PUBLIC void httpPruneMonitors()
             httpLog(http->trace, "monitor.ban.stop", "context", "client:'%s'", kp->key);
             address->banUntil = 0;
         }
-        if ((address->updated + period) < http->now && address->banUntil == 0) {
-            mprRemoveKey(http->addresses, kp->key);
-            /* Safe to keep iterating after removal of key */
+        /*
+            Remove address if not banned, not active in the last (1 minute) and no active connections.
+         */
+        if ((address->updated + ME_HTTP_MONITOR_PERIOD) < http->now && address->banUntil == 0) {
+            if (address->counters[HTTP_COUNTER_ACTIVE_CONNECTIONS].value == 0) {
+                mprLog("error http monitor", 1, "Restored access for IP %s", kp->key);
+                mprRemoveKey(http->addresses, kp->key);
+                /* Safe to keep iterating after removal of key */
+            }
         }
     }
     unlock(http->addresses);
@@ -13481,6 +13461,10 @@ static void stopMonitors()
 }
 
 
+/*
+    Return the monitor counters for a network address based on the net->ip.
+    Allocate or grow the counters sufficient to store the max counter index.
+ */
 PUBLIC HttpAddress *httpMonitorAddress(HttpNet *net, int counterIndex)
 {
     Http            *http;
@@ -13500,13 +13484,13 @@ PUBLIC HttpAddress *httpMonitorAddress(HttpNet *net, int counterIndex)
     address = mprLookupKey(http->addresses, net->ip);
     if (!address) {
         count = mprGetHashLength(http->addresses);
-        if (count > net->limits->clientMax) {
-            mprLog("net info", 3, "Too many concurrent clients, active: %d, max:%d", count, net->limits->clientMax);
+        if (count >= net->limits->clientMax) {
             unlock(http->addresses);
             return 0;
         }
     }
-    if ((address = growAddresses(net, address, counterIndex)) == 0) {
+    if ((address = growCounters(net, address, counterIndex)) == 0) {
+        /* Cannot happen */
         unlock(http->addresses);
         return 0;
     }
@@ -13522,11 +13506,12 @@ PUBLIC HttpAddress *httpMonitorAddress(HttpNet *net, int counterIndex)
 }
 
 
-static HttpAddress *growAddresses(HttpNet *net, HttpAddress *address, int counterIndex)
+static HttpAddress *growCounters(HttpNet *net, HttpAddress *address, int counterIndex)
 {
     int     ncounters;
 
     if (!address || address->ncounters <= counterIndex) {
+        //  Round to 16
         ncounters = ((counterIndex + 0xF) & ~0xF);
         if (address) {
             address = mprRealloc(address, sizeof(HttpAddress) * ncounters * sizeof(HttpCounter));
@@ -14423,6 +14408,7 @@ PUBLIC int httpOpenNetConnector()
  */
 PUBLIC HttpNet *httpAccept(HttpEndpoint *endpoint, MprEvent *event)
 {
+    Http        *http;
     HttpNet     *net;
     HttpAddress *address;
     HttpLimits  *limits;
@@ -14444,23 +14430,39 @@ PUBLIC HttpNet *httpAccept(HttpEndpoint *endpoint, MprEvent *event)
     }
     httpBindSocket(net, sock);
     limits = net->limits;
+    http = net->http;
 
+#if KEEP
+    //  Useful for debugging and simulating multiple clients
+    net->ip = mprGetRandomString(16);
+#endif
     if ((address = httpMonitorAddress(net, 0)) == 0) {
-        mprCloseSocket(sock, 0);
+        mprLog("net info", 1, "Connection denied for IP %s. Too many concurrent clients, active: %d, max:%d",
+            net->ip, mprGetHashLength(http->addresses), net->limits->clientMax);
+        httpMonitorNetEvent(net, HTTP_COUNTER_ACTIVE_CONNECTIONS, 1);
+        httpDestroyNet(net);
         return 0;
     }
-    if ((value = httpMonitorNetEvent(net, HTTP_COUNTER_ACTIVE_CONNECTIONS, 1)) > limits->connectionsMax) {
-        mprLog("net info", 3, "Too many concurrent connections, active: %d, max:%d", (int) value - 1, limits->connectionsMax);
+    if ((value = httpMonitorNetEvent(net, HTTP_COUNTER_ACTIVE_CONNECTIONS, 1)) > limits->connectionsPerClientMax) {
+        mprLog("net info", 1, "Connection denied for IP %s. Too many concurrent connections for client, active: %d, max: %d",
+            net->ip, (int) (value - 1), limits->connectionsPerClientMax);
+        httpDestroyNet(net);
+        return 0;
+    }
+    if (mprGetListLength(http->networks) > limits->connectionsMax) {
+        mprLog("net info", 1, "Connection denied for IP %s. Too many concurrent connections for the server, active: %d, max: %d",
+            net->ip, mprGetListLength(http->networks), limits->connectionsMax);
         httpDestroyNet(net);
         return 0;
     }
     address = net->address;
     if (address && address->banUntil) {
         if (address->banUntil < net->http->now) {
-            mprLog("net info", 3, "Stop ban for client %s", net->ip);
+            mprLog("net info", 1, "Remove ban for client IP %s", net->ip);
             address->banUntil = 0;
         } else {
-            mprLog("net info", 3, "Network connection refused, client banned: %s", address->banMsg ? address->banMsg : "");
+            mprLog("net info", 1, "Network connection refused for client IP %s, client banned: %s", net->ip,
+                address->banMsg ? address->banMsg : "");
             httpDestroyNet(net);
             return 0;
         }
@@ -16256,9 +16258,30 @@ static int sendContinue(HttpQueue *q);
 
 PUBLIC bool httpProcessHeaders(HttpQueue *q)
 {
+    HttpNet     *net;
+    HttpStream  *stream;
+    HttpLimits  *limits;
+    int64       value;
+
     if (q->stream->state != HTTP_STATE_PARSED) {
         return 0;
     }
+    stream = q->stream;
+    net = stream->net;
+    limits = net->limits;
+
+    if (httpServerStream(stream) && !stream->activeRequest) {
+        /*
+            ErrorDocuments may come through here twice so test activeRequest to keep counters valid.
+         */
+        stream->activeRequest = 1;
+        if ((value = httpMonitorEvent(stream, HTTP_COUNTER_ACTIVE_REQUESTS, 1)) > limits->requestsPerClientMax) {
+            httpError(stream, HTTP_ABORT | HTTP_CODE_SERVICE_UNAVAILABLE,
+                "Request denied for IP %s. Too many concurrent requests for client, active: %d max: %d", stream->ip, (int) value, limits->requestsPerClientMax);
+            return 1;
+        }
+        httpMonitorEvent(stream, HTTP_COUNTER_REQUESTS, 1);
+    }
     processFirst(q);
     processHeaders(q);
     processParsed(q);
@@ -24159,7 +24182,7 @@ PUBLIC void httpDetailFormatter(HttpTrace *trace, cchar *event, cchar *type, int
 
     now = mprGetTime();
     if (trace->lastMark < (now + TPS) || trace->lastTime == 0) {
-        trace->lastTime = mprGetDate("%T");
+        trace->lastTime = mprGetDate("%D %T");
         trace->lastMark = now;
     }
 

## Improve error messages

diff --git a/src/mpr/mprLib.c b/src/mpr/mprLib.c
index 1c35d3258..22b3094f5 100644
--- a/src/mpr/mprLib.c
+++ b/src/mpr/mprLib.c
@@ -28548,13 +28548,15 @@ static MprWaitHandler *initWaitHandler(MprWaitHandler *wp, int fd, int mask, Mpr
     wp->flags           = flags;
 
     if (mprGetListLength(ws->handlers) >= FD_SETSIZE) {
-        mprLog("error mpr event", 0, "Too many io handlers: %d", FD_SETSIZE);
+        mprLog("error mpr event", 1, 
+            "Too many io handlers: FD_SETSIZE %d, increase FD_SETSIZE or reduce limits", FD_SETSIZE);
         return 0;
     }
 #if ME_UNIX_LIKE || VXWORKS
 #if ME_EVENT_NOTIFIER == MPR_EVENT_SELECT
     if (fd >= FD_SETSIZE) {
-        mprLog("error mpr event", 0, "File descriptor %d exceeds max io of %d", fd, FD_SETSIZE);
+        mprLog("error mpr event", 1, "File descriptor %d exceeds max FD_SETSIZE of %d, increase FD_SETSIZE or reduce limits",
+            fd, FD_SETSIZE);
     }
 #endif
 #endif


## Add sys/event.h to osdep.h

diff --git a/src/osdep/osdep.h b/src/osdep/osdep.h
index 423c85a77..1162b1f21 100644
--- a/src/osdep/osdep.h
+++ b/src/osdep/osdep.h
@@ -386,6 +386,7 @@
 #if ME_BSD_LIKE
     #include    <readpassphrase.h>
     #include    <sys/sysctl.h>
+    #include    <sys/event.h>
 #endif
     #include    <setjmp.h>
     #include    <signal.h>
